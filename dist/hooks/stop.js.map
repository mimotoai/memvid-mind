{"version":3,"sources":["../../src/types.ts","../../src/utils/helpers.ts","../../src/core/mind.ts","../../src/hooks/stop.ts"],"names":["resolve"],"mappings":"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","file":"stop.js","sourcesContent":["/**\n * Memvid Mind - Type Definitions\n *\n * Core types for Claude Code memory persistence.\n */\n\n/** Observation captured from tool use */\nexport interface Observation {\n  id: string;\n  timestamp: number;\n  type: ObservationType;\n  tool?: string;\n  summary: string;\n  content: string;\n  metadata?: ObservationMetadata;\n}\n\n/** Types of observations */\nexport type ObservationType =\n  | \"discovery\"      // New information discovered\n  | \"decision\"       // Decision made\n  | \"problem\"        // Problem identified\n  | \"solution\"       // Solution implemented\n  | \"pattern\"        // Pattern recognized\n  | \"warning\"        // Warning or concern\n  | \"success\"        // Successful outcome\n  | \"refactor\"       // Code refactored\n  | \"bugfix\"         // Bug fixed\n  | \"feature\";       // Feature added\n\n/** Metadata attached to observations */\nexport interface ObservationMetadata {\n  files?: string[];\n  functions?: string[];\n  error?: string;\n  confidence?: number;\n  tags?: string[];\n  sessionId?: string;\n  [key: string]: unknown;  // Allow additional properties\n}\n\n/** Session summary stored at end of session */\nexport interface SessionSummary {\n  id: string;\n  startTime: number;\n  endTime: number;\n  observationCount: number;\n  keyDecisions: string[];\n  filesModified: string[];\n  summary: string;\n}\n\n/** Context injected at session start */\nexport interface InjectedContext {\n  recentObservations: Observation[];\n  relevantMemories: Observation[];\n  sessionSummaries: SessionSummary[];\n  tokenCount: number;\n}\n\n/** Configuration for Memvid Mind */\nexport interface MindConfig {\n  /** Path to the .memvid file (default: .mind.mv2 in project root) */\n  memoryPath: string;\n  /** Maximum observations to inject at session start */\n  maxContextObservations: number;\n  /** Maximum tokens for context injection */\n  maxContextTokens: number;\n  /** Whether to auto-compress observations */\n  autoCompress: boolean;\n  /** Minimum confidence for storing observations */\n  minConfidence: number;\n  /** Enable debug logging */\n  debug: boolean;\n}\n\n/** Default configuration */\nexport const DEFAULT_CONFIG: MindConfig = {\n  memoryPath: \".claude/mind.mv2\",\n  maxContextObservations: 20,\n  maxContextTokens: 2000,\n  autoCompress: true,\n  minConfidence: 0.6,\n  debug: false,\n};\n\n/** Hook input from Claude Code */\nexport interface HookInput {\n  session_id: string;\n  transcript_path?: string;\n  cwd?: string;\n  hook_event_name?: string;\n  permission_mode?: string;\n  tool_name?: string;\n  tool_input?: Record<string, unknown>;\n  tool_response?: unknown; // Can be object or string depending on tool\n  tool_use_id?: string;\n}\n\n/** Hook output to Claude Code */\nexport interface HookOutput {\n  continue?: boolean;\n  result?: string;\n  decision?: \"block\" | \"approve\" | \"modify\";\n  reason?: string;\n  modified_input?: Record<string, unknown>;\n}\n\n/** Search result from memory */\nexport interface MemorySearchResult {\n  observation: Observation;\n  score: number;\n  snippet: string;\n}\n\n/** Statistics about the mind file */\nexport interface MindStats {\n  totalObservations: number;\n  totalSessions: number;\n  oldestMemory: number;\n  newestMemory: number;\n  fileSize: number;\n  topTypes: Record<ObservationType, number>;\n}\n","/**\n * Memvid Mind - Utility Helpers\n */\n\nimport { randomBytes } from \"node:crypto\";\n\n/**\n * Generate a unique ID\n */\nexport function generateId(): string {\n  return randomBytes(8).toString(\"hex\");\n}\n\n/**\n * Estimate token count for text (rough approximation)\n * ~4 characters per token for English text\n */\nexport function estimateTokens(text: string): number {\n  return Math.ceil(text.length / 4);\n}\n\n/**\n * Truncate text to fit within token limit\n */\nexport function truncateToTokens(text: string, maxTokens: number): string {\n  const maxChars = maxTokens * 4;\n  if (text.length <= maxChars) return text;\n  return text.slice(0, maxChars - 3) + \"...\";\n}\n\n/**\n * Format timestamp to human-readable string\n */\nexport function formatTimestamp(ts: number): string {\n  const date = new Date(ts);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffMins = Math.floor(diffMs / 60000);\n  const diffHours = Math.floor(diffMs / 3600000);\n  const diffDays = Math.floor(diffMs / 86400000);\n\n  if (diffMins < 1) return \"just now\";\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 7) return `${diffDays}d ago`;\n\n  return date.toLocaleDateString();\n}\n\n/**\n * Parse JSON safely\n */\nexport function safeJsonParse<T>(text: string, fallback: T): T {\n  try {\n    return JSON.parse(text) as T;\n  } catch {\n    return fallback;\n  }\n}\n\n/**\n * Read all stdin as string\n */\nexport async function readStdin(): Promise<string> {\n  const chunks: Buffer[] = [];\n\n  return new Promise((resolve, reject) => {\n    process.stdin.on(\"data\", (chunk) => chunks.push(chunk));\n    process.stdin.on(\"end\", () => resolve(Buffer.concat(chunks).toString(\"utf8\")));\n    process.stdin.on(\"error\", reject);\n  });\n}\n\n/**\n * Write JSON to stdout and exit immediately\n * (Prevents SDK background tasks from blocking process exit)\n */\nexport function writeOutput(output: unknown): never {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\n\n/**\n * Log debug message to stderr\n */\nexport function debug(message: string): void {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\n\n/**\n * Extract key information from tool output\n */\nexport function extractKeyInfo(toolName: string, output: string): string {\n  // Truncate very long outputs\n  const maxLength = 2000;\n  const truncated = output.length > maxLength\n    ? output.slice(0, maxLength) + \"\\n... (truncated)\"\n    : output;\n\n  // Tool-specific extraction\n  switch (toolName) {\n    case \"Read\":\n      // Extract file summary from read output\n      return extractFileReadSummary(truncated);\n    case \"Bash\":\n      // Extract command summary\n      return extractBashSummary(truncated);\n    case \"Edit\":\n      // Extract edit summary\n      return extractEditSummary(truncated);\n    case \"Grep\":\n    case \"Glob\":\n      // Extract search summary\n      return extractSearchSummary(truncated);\n    default:\n      return truncated;\n  }\n}\n\nfunction extractFileReadSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 20) return output;\n  return `${lines.slice(0, 10).join(\"\\n\")}\\n... (${lines.length} lines total)`;\n}\n\nfunction extractBashSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 30) return output;\n  return [\n    ...lines.slice(0, 10),\n    `... (${lines.length - 20} lines omitted)`,\n    ...lines.slice(-10),\n  ].join(\"\\n\");\n}\n\nfunction extractEditSummary(output: string): string {\n  // Edits are usually compact, return as-is\n  return output;\n}\n\nfunction extractSearchSummary(output: string): string {\n  const lines = output.split(\"\\n\").filter(Boolean);\n  if (lines.length <= 20) return output;\n  return [\n    ...lines.slice(0, 15),\n    `... and ${lines.length - 15} more results`,\n  ].join(\"\\n\");\n}\n\n/**\n * Classify observation type from tool and output\n */\nexport function classifyObservationType(\n  toolName: string,\n  output: string\n): \"discovery\" | \"decision\" | \"problem\" | \"solution\" | \"pattern\" | \"warning\" | \"success\" | \"refactor\" | \"bugfix\" | \"feature\" {\n  const lowerOutput = output.toLowerCase();\n\n  // Error detection\n  if (\n    lowerOutput.includes(\"error\") ||\n    lowerOutput.includes(\"failed\") ||\n    lowerOutput.includes(\"exception\")\n  ) {\n    return \"problem\";\n  }\n\n  // Success detection\n  if (\n    lowerOutput.includes(\"success\") ||\n    lowerOutput.includes(\"passed\") ||\n    lowerOutput.includes(\"completed\")\n  ) {\n    return \"success\";\n  }\n\n  // Warning detection\n  if (lowerOutput.includes(\"warning\") || lowerOutput.includes(\"deprecated\")) {\n    return \"warning\";\n  }\n\n  // Tool-based classification\n  switch (toolName) {\n    case \"Read\":\n    case \"Glob\":\n    case \"Grep\":\n      return \"discovery\";\n    case \"Edit\":\n      if (lowerOutput.includes(\"fix\") || lowerOutput.includes(\"bug\")) {\n        return \"bugfix\";\n      }\n      return \"refactor\";\n    case \"Write\":\n      return \"feature\";\n    default:\n      return \"discovery\";\n  }\n}\n","/**\n * Memvid Mind - Core Engine\n *\n * The brain behind Claude's persistent memory.\n * Stores everything in ONE portable .memvid file.\n */\n\n// Use dynamic import to allow smart-install to run first\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Memvid = any;\n\nimport { existsSync } from \"node:fs\";\nimport { resolve, dirname } from \"node:path\";\nimport { mkdir } from \"node:fs/promises\";\nimport {\n  type Observation,\n  type ObservationType,\n  type SessionSummary,\n  type InjectedContext,\n  type MindConfig,\n  type MindStats,\n  type MemorySearchResult,\n  DEFAULT_CONFIG,\n} from \"../types.js\";\nimport { generateId, estimateTokens } from \"../utils/helpers.js\";\n\n// Lazy-loaded SDK functions\nlet sdkLoaded = false;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet use: any;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet create: any;\n\nasync function loadSDK(): Promise<void> {\n  if (sdkLoaded) return;\n  const sdk = await import(\"@memvid/sdk\");\n  use = sdk.use;\n  create = sdk.create;\n  sdkLoaded = true;\n}\n\n/**\n * Mind - Claude's portable memory engine\n *\n * @example\n * ```typescript\n * const mind = await Mind.open();\n * await mind.remember({\n *   type: \"decision\",\n *   summary: \"Chose React over Vue for frontend\",\n *   content: \"Decision rationale: team familiarity, ecosystem...\"\n * });\n *\n * const context = await mind.getContext(\"authentication\");\n * ```\n */\nexport class Mind {\n  private memvid: Memvid;\n  private config: MindConfig;\n  private sessionId: string;\n  private initialized = false;\n\n  private constructor(memvid: Memvid, config: MindConfig) {\n    this.memvid = memvid;\n    this.config = config;\n    this.sessionId = generateId();\n  }\n\n  /**\n   * Open or create a Mind instance\n   */\n  static async open(configOverrides: Partial<MindConfig> = {}): Promise<Mind> {\n    // Load SDK dynamically (allows smart-install to run first)\n    await loadSDK();\n\n    const config = { ...DEFAULT_CONFIG, ...configOverrides };\n\n    // Resolve path relative to project dir (use CLAUDE_PROJECT_DIR if available)\n    const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();\n    const memoryPath = resolve(projectDir, config.memoryPath);\n    const memoryDir = dirname(memoryPath);\n\n    // Ensure directory exists\n    await mkdir(memoryDir, { recursive: true });\n\n    // Open or create the memvid file\n    let memvid;\n    const MAX_FILE_SIZE_MB = 100; // Files over 100MB are likely corrupted\n\n    if (!existsSync(memoryPath)) {\n      memvid = await create(memoryPath, \"basic\");\n    } else {\n      // Check file size - very large files are likely corrupted and will hang\n      const { statSync, renameSync, unlinkSync } = await import(\"node:fs\");\n      const fileSize = statSync(memoryPath).size;\n      const fileSizeMB = fileSize / (1024 * 1024);\n\n      if (fileSizeMB > MAX_FILE_SIZE_MB) {\n        console.error(`[memvid-mind] Memory file too large (${fileSizeMB.toFixed(1)}MB), likely corrupted. Creating fresh memory...`);\n        const backupPath = `${memoryPath}.backup-${Date.now()}`;\n        try { renameSync(memoryPath, backupPath); } catch { /* ignore */ }\n        memvid = await create(memoryPath, \"basic\");\n      } else {\n        try {\n          memvid = await use(\"basic\", memoryPath);\n        } catch (openError: unknown) {\n          const errorMessage = openError instanceof Error ? openError.message : String(openError);\n          // Handle corrupted or incompatible memory files\n          if (errorMessage.includes(\"Deserialization\") ||\n              errorMessage.includes(\"UnexpectedVariant\") ||\n              errorMessage.includes(\"Invalid\") ||\n              errorMessage.includes(\"corrupt\")) {\n            console.error(\"[memvid-mind] Memory file corrupted, creating fresh memory...\");\n            const backupPath = `${memoryPath}.backup-${Date.now()}`;\n            try {\n              renameSync(memoryPath, backupPath);\n            } catch {\n              try { unlinkSync(memoryPath); } catch { /* ignore */ }\n            }\n            memvid = await create(memoryPath, \"basic\");\n          } else {\n            throw openError;\n          }\n        }\n      }\n    }\n\n    const mind = new Mind(memvid, config);\n    mind.initialized = true;\n\n    if (config.debug) {\n      console.error(`[memvid-mind] Opened: ${memoryPath}`);\n    }\n\n    return mind;\n  }\n\n  /**\n   * Remember an observation\n   */\n  async remember(input: {\n    type: ObservationType;\n    summary: string;\n    content: string;\n    tool?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<string> {\n    const observation: Observation = {\n      id: generateId(),\n      timestamp: Date.now(),\n      type: input.type,\n      tool: input.tool,\n      summary: input.summary,\n      content: input.content,\n      metadata: {\n        ...input.metadata,\n        sessionId: this.sessionId,\n      },\n    };\n\n    // Store in memvid\n    const frameId = await this.memvid.put({\n      title: `[${observation.type}] ${observation.summary}`,\n      label: observation.type,\n      text: observation.content,\n      metadata: {\n        observationId: observation.id,\n        timestamp: observation.timestamp,\n        tool: observation.tool,\n        sessionId: this.sessionId,\n        ...observation.metadata,\n      },\n      tags: [observation.type, observation.tool].filter(Boolean) as string[],\n    });\n\n    if (this.config.debug) {\n      console.error(`[memvid-mind] Remembered: ${observation.summary}`);\n    }\n\n    return frameId;\n  }\n\n  /**\n   * Search memories by query (uses fast lexical search)\n   */\n  async search(query: string, limit = 10): Promise<MemorySearchResult[]> {\n    const results = await this.memvid.find(query, { k: limit, mode: \"lex\" });\n\n    return (results.frames || []).map((frame: any) => ({\n      observation: {\n        id: frame.metadata?.observationId || frame.frame_id,\n        timestamp: frame.metadata?.timestamp || 0,\n        type: frame.label as ObservationType,\n        tool: frame.metadata?.tool,\n        summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || \"\",\n        content: frame.text || \"\",\n        metadata: frame.metadata,\n      },\n      score: frame.score || 0,\n      snippet: frame.snippet || frame.text?.slice(0, 200) || \"\",\n    }));\n  }\n\n  /**\n   * Ask the memory a question (uses fast lexical search)\n   */\n  async ask(question: string): Promise<string> {\n    const result = await this.memvid.ask(question, { k: 5, mode: \"lex\" });\n    return result.answer || \"No relevant memories found.\";\n  }\n\n  /**\n   * Get context for session start\n   */\n  async getContext(query?: string): Promise<InjectedContext> {\n    // Get recent observations via timeline\n    const timeline = await this.memvid.timeline({\n      limit: this.config.maxContextObservations,\n      reverse: true,\n    });\n\n    // SDK returns array directly or { frames: [...] }\n    const frames = Array.isArray(timeline) ? timeline : (timeline.frames || []);\n\n    const recentObservations: Observation[] = frames.map(\n      (frame: any) => {\n        // Get timestamp - SDK returns seconds, convert to milliseconds if needed\n        let ts = frame.metadata?.timestamp || frame.timestamp || 0;\n        // If timestamp looks like seconds (before year 2100 in seconds), convert to ms\n        if (ts > 0 && ts < 4102444800) {\n          ts = ts * 1000;\n        }\n        return {\n          id: frame.metadata?.observationId || frame.frame_id,\n          timestamp: ts,\n          type: (frame.label || frame.metadata?.type || \"observation\") as ObservationType,\n          tool: frame.metadata?.tool,\n          summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || frame.preview?.slice(0, 100) || \"\",\n          content: frame.text || frame.preview || \"\",\n          metadata: frame.metadata,\n        };\n      }\n    );\n\n    // Get relevant memories if query provided\n    let relevantMemories: Observation[] = [];\n    if (query) {\n      const searchResults = await this.search(query, 10);\n      relevantMemories = searchResults.map((r) => r.observation);\n    }\n\n    // Build context with token limit\n    const contextParts: string[] = [];\n    let tokenCount = 0;\n\n    // Add recent observations\n    for (const obs of recentObservations) {\n      const text = `[${obs.type}] ${obs.summary}`;\n      const tokens = estimateTokens(text);\n      if (tokenCount + tokens > this.config.maxContextTokens) break;\n      contextParts.push(text);\n      tokenCount += tokens;\n    }\n\n    return {\n      recentObservations,\n      relevantMemories,\n      sessionSummaries: [], // TODO: Implement session summaries\n      tokenCount,\n    };\n  }\n\n  /**\n   * Save a session summary\n   */\n  async saveSessionSummary(summary: {\n    keyDecisions: string[];\n    filesModified: string[];\n    summary: string;\n  }): Promise<string> {\n    const sessionSummary: SessionSummary = {\n      id: this.sessionId,\n      startTime: Date.now() - 3600000, // Approximate\n      endTime: Date.now(),\n      observationCount: 0, // TODO: Track this\n      keyDecisions: summary.keyDecisions,\n      filesModified: summary.filesModified,\n      summary: summary.summary,\n    };\n\n    return this.memvid.put({\n      title: `Session Summary: ${new Date().toISOString().split(\"T\")[0]}`,\n      label: \"session\",\n      text: JSON.stringify(sessionSummary, null, 2),\n      metadata: sessionSummary as unknown as Record<string, unknown>,\n      tags: [\"session\", \"summary\"],\n    });\n  }\n\n  /**\n   * Get memory statistics\n   */\n  async stats(): Promise<MindStats> {\n    const stats = await this.memvid.stats();\n    const timeline = await this.memvid.timeline({ limit: 1, reverse: false });\n    const recentTimeline = await this.memvid.timeline({ limit: 1, reverse: true });\n\n    // SDK returns array directly or { frames: [...] }\n    const oldestFrames = Array.isArray(timeline) ? timeline : (timeline.frames || []);\n    const newestFrames = Array.isArray(recentTimeline) ? recentTimeline : (recentTimeline.frames || []);\n\n    return {\n      totalObservations: (stats.frame_count as number) || 0,\n      totalSessions: 0, // TODO: Count unique sessions\n      oldestMemory: (oldestFrames[0] as any)?.metadata?.timestamp || (oldestFrames[0] as any)?.timestamp || 0,\n      newestMemory: (newestFrames[0] as any)?.metadata?.timestamp || (newestFrames[0] as any)?.timestamp || 0,\n      fileSize: (stats.size_bytes as number) || 0,\n      topTypes: {} as Record<ObservationType, number>, // TODO: Aggregate\n    };\n  }\n\n  /**\n   * Get the session ID\n   */\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  /**\n   * Get the memory file path\n   */\n  getMemoryPath(): string {\n    return resolve(process.cwd(), this.config.memoryPath);\n  }\n\n  /**\n   * Check if initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\n// Singleton instance for hooks\nlet mindInstance: Mind | null = null;\n\n/**\n * Get or create the Mind singleton\n */\nexport async function getMind(config?: Partial<MindConfig>): Promise<Mind> {\n  if (!mindInstance) {\n    mindInstance = await Mind.open(config);\n  }\n  return mindInstance;\n}\n\n/**\n * Reset the Mind singleton (for testing)\n */\nexport function resetMind(): void {\n  mindInstance = null;\n}\n","#!/usr/bin/env node\n/**\n * Memvid Mind - Stop Hook\n *\n * AUTO SESSION SUMMARY\n * Runs when Claude session ends.\n * Generates an intelligent session summary for future reference.\n *\n * WORKAROUND: Since PostToolUse doesn't fire for Edit operations (Claude Code bug),\n * we capture git diff at session end to record all file modifications.\n */\n\nimport { getMind } from \"../core/mind.js\";\nimport { readStdin, writeOutput, debug } from \"../utils/helpers.js\";\nimport type { HookInput, HookOutput } from \"../types.js\";\nimport { readFile, access } from \"node:fs/promises\";\nimport { constants } from \"node:fs\";\nimport { execSync } from \"node:child_process\";\n\n// Minimum observations to generate a session summary\nconst MIN_OBSERVATIONS_FOR_SUMMARY = 3;\n\n/**\n * Capture file modifications at session end\n * WORKAROUND for Claude Code bug: PostToolUse hooks don't fire for Edit operations\n *\n * Captures both:\n * 1. Git tracked files that changed (git diff)\n * 2. Recently modified files in untracked directories (find -mmin)\n */\nasync function captureFileChanges(mind: Awaited<ReturnType<typeof getMind>>) {\n  try {\n    // Get the working directory from the mind's memory path\n    const memoryPath = mind.getMemoryPath();\n    const workDir = memoryPath.replace(/\\/\\.claude\\/.*$/, \"\");\n\n    const allChangedFiles: string[] = [];\n    let gitDiffContent = \"\";\n\n    // 1. Get git tracked changes (staged and unstaged)\n    try {\n      const diffNames = execSync(\"git diff --name-only HEAD 2>/dev/null || git diff --name-only\", {\n        cwd: workDir,\n        encoding: \"utf-8\",\n        timeout: 5000,\n      }).trim();\n\n      const stagedNames = execSync(\"git diff --cached --name-only 2>/dev/null || true\", {\n        cwd: workDir,\n        encoding: \"utf-8\",\n        timeout: 5000,\n      }).trim();\n\n      const gitFiles = [...new Set([\n        ...diffNames.split(\"\\n\").filter(Boolean),\n        ...stagedNames.split(\"\\n\").filter(Boolean),\n      ])];\n\n      allChangedFiles.push(...gitFiles);\n\n      // Get git diff stat for tracked files\n      if (gitFiles.length > 0) {\n        try {\n          gitDiffContent = execSync(\"git diff HEAD --stat 2>/dev/null | head -50\", {\n            cwd: workDir,\n            encoding: \"utf-8\",\n            timeout: 10000,\n          }).trim();\n        } catch {\n          // Ignore\n        }\n      }\n    } catch {\n      // Not a git repo or git not available - continue to find recent files\n    }\n\n    // 2. Find recently modified files (last 60 minutes) in common code directories\n    // This catches changes in untracked directories\n    // Use -maxdepth to limit search and exclude common large dirs for speed\n    try {\n      const recentFiles = execSync(\n        `find . -maxdepth 5 -type f \\\\( -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.jsx\" -o -name \"*.md\" -o -name \"*.json\" -o -name \"*.py\" -o -name \"*.rs\" \\\\) -mmin -60 ! -path \"*/node_modules/*\" ! -path \"*/.git/*\" ! -path \"*/dist/*\" ! -path \"*/build/*\" ! -path \"*/.next/*\" ! -path \"*/target/*\" 2>/dev/null | head -50`,\n        {\n          cwd: workDir,\n          encoding: \"utf-8\",\n          timeout: 15000,\n        }\n      ).trim();\n\n      const recentFilesList = recentFiles.split(\"\\n\").filter(Boolean).map(f => f.replace(/^\\.\\//, \"\"));\n\n      // Add files not already in the list\n      for (const file of recentFilesList) {\n        if (!allChangedFiles.includes(file)) {\n          allChangedFiles.push(file);\n        }\n      }\n    } catch {\n      // find command failed, continue with what we have\n    }\n\n    if (allChangedFiles.length === 0) {\n      debug(\"No file changes detected\");\n      return;\n    }\n\n    debug(`Capturing ${allChangedFiles.length} changed files`);\n\n    // Build content summary\n    const contentParts = [`## Files Modified This Session\\n\\n${allChangedFiles.map(f => `- ${f}`).join(\"\\n\")}`];\n\n    if (gitDiffContent) {\n      contentParts.push(`\\n## Git Changes Summary\\n\\`\\`\\`\\n${gitDiffContent}\\n\\`\\`\\``);\n    }\n\n    // Store the changes as a memory\n    await mind.remember({\n      type: \"refactor\",\n      summary: `Session edits: ${allChangedFiles.length} file(s) modified`,\n      content: contentParts.join(\"\\n\"),\n      tool: \"FileChanges\",\n      metadata: {\n        files: allChangedFiles,\n        fileCount: allChangedFiles.length,\n        captureMethod: \"git-diff-plus-recent\",\n      },\n    });\n\n    // Also store individual entries for important file types (README, config, etc.)\n    // so they're searchable by name\n    for (const file of allChangedFiles) {\n      const fileName = file.split(\"/\").pop() || file;\n      const isImportant = /^(README|CHANGELOG|package\\.json|Cargo\\.toml|\\.env)/i.test(fileName);\n\n      if (isImportant) {\n        await mind.remember({\n          type: \"refactor\",\n          summary: `Modified ${fileName}`,\n          content: `File edited: ${file}\\nThis file was modified during the session.`,\n          tool: \"FileEdit\",\n          metadata: {\n            files: [file],\n            fileName,\n          },\n        });\n        debug(`Stored individual edit: ${fileName}`);\n      }\n    }\n\n    debug(`Stored file changes: ${allChangedFiles.length} files`);\n  } catch (error) {\n    debug(`Failed to capture file changes: ${error}`);\n  }\n}\n\nasync function main() {\n  try {\n    // Read hook input from stdin\n    const input = await readStdin();\n    const hookInput: HookInput = JSON.parse(input);\n\n    debug(`Session stopping: ${hookInput.session_id}`);\n\n    // Initialize mind\n    const mind = await getMind();\n    const stats = await mind.stats();\n\n    // WORKAROUND: Capture file changes since PostToolUse doesn't fire for Edit\n    await captureFileChanges(mind);\n\n    // Try to read the transcript for richer summary\n    let transcriptContent = \"\";\n    if (hookInput.transcript_path) {\n      try {\n        await access(hookInput.transcript_path, constants.R_OK);\n        transcriptContent = await readFile(hookInput.transcript_path, \"utf-8\");\n      } catch {\n        // Transcript not available, that's ok\n      }\n    }\n\n    // Get recent observations from this session\n    const context = await mind.getContext();\n    const sessionObservations = context.recentObservations.filter(\n      (obs) => obs.metadata?.sessionId === mind.getSessionId()\n    );\n\n    // Generate session summary if we have enough observations\n    if (sessionObservations.length >= MIN_OBSERVATIONS_FOR_SUMMARY) {\n      const summary = generateSessionSummary(\n        sessionObservations,\n        transcriptContent\n      );\n\n      // Save the session summary\n      await mind.saveSessionSummary(summary);\n\n      debug(\n        `Session summary saved: ${summary.keyDecisions.length} decisions, ${summary.filesModified.length} files`\n      );\n    }\n\n    debug(\n      `Session complete. Total memories: ${stats.totalObservations}, File: ${mind.getMemoryPath()}`\n    );\n\n    // Continue without blocking\n    const output: HookOutput = {\n      continue: true,\n    };\n\n    writeOutput(output);\n  } catch (error) {\n    debug(`Error: ${error}`);\n    // Don't block on errors\n    writeOutput({ continue: true });\n  }\n}\n\n/**\n * Generate a session summary from observations\n */\nfunction generateSessionSummary(\n  observations: Array<{\n    type: string;\n    summary: string;\n    content: string;\n    metadata?: { files?: string[]; sessionId?: string; [key: string]: unknown };\n  }>,\n  transcript: string\n): {\n  keyDecisions: string[];\n  filesModified: string[];\n  summary: string;\n} {\n  // Extract key decisions\n  const keyDecisions: string[] = [];\n  const filesModified = new Set<string>();\n\n  for (const obs of observations) {\n    // Track decisions\n    if (\n      obs.type === \"decision\" ||\n      obs.summary.toLowerCase().includes(\"chose\") ||\n      obs.summary.toLowerCase().includes(\"decided\")\n    ) {\n      keyDecisions.push(obs.summary);\n    }\n\n    // Track files from metadata\n    const files = obs.metadata?.files as string[] | undefined;\n    if (files) {\n      files.forEach((f) => filesModified.add(f));\n    }\n  }\n\n  // Extract file paths from transcript if available\n  if (transcript) {\n    const filePatterns = [\n      /(?:Read|Edit|Write)[^\"]*\"([^\"]+)\"/g,\n      /file_path[\"\\s:]+([^\\s\"]+)/g,\n    ];\n\n    for (const pattern of filePatterns) {\n      let match;\n      while ((match = pattern.exec(transcript)) !== null) {\n        const path = match[1];\n        if (path && !path.includes(\"node_modules\") && !path.startsWith(\".\")) {\n          filesModified.add(path);\n        }\n      }\n    }\n  }\n\n  // Generate summary based on observation types\n  const typeCounts: Record<string, number> = {};\n  for (const obs of observations) {\n    typeCounts[obs.type] = (typeCounts[obs.type] || 0) + 1;\n  }\n\n  const summaryParts: string[] = [];\n\n  if (typeCounts.feature) {\n    summaryParts.push(`Added ${typeCounts.feature} feature(s)`);\n  }\n  if (typeCounts.bugfix) {\n    summaryParts.push(`Fixed ${typeCounts.bugfix} bug(s)`);\n  }\n  if (typeCounts.refactor) {\n    summaryParts.push(`Refactored ${typeCounts.refactor} item(s)`);\n  }\n  if (typeCounts.discovery) {\n    summaryParts.push(`Made ${typeCounts.discovery} discovery(ies)`);\n  }\n  if (typeCounts.problem) {\n    summaryParts.push(`Encountered ${typeCounts.problem} problem(s)`);\n  }\n  if (typeCounts.solution) {\n    summaryParts.push(`Found ${typeCounts.solution} solution(s)`);\n  }\n\n  const summary =\n    summaryParts.length > 0\n      ? summaryParts.join(\". \") + \".\"\n      : `Session with ${observations.length} observations.`;\n\n  return {\n    keyDecisions: keyDecisions.slice(0, 10),\n    filesModified: Array.from(filesModified).slice(0, 20),\n    summary,\n  };\n}\n\nmain();\n"]}